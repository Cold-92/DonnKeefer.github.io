<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Joint application of HashMap，HashSet in Java SE</title>
    <url>/blob03.html</url>
    <content><![CDATA[<p>Joint application of HashMap，HashSet in Java SE</p>
<a id="more"></a>
<h2 id="利用HashMap做一个小型购物车系统"><a href="#利用HashMap做一个小型购物车系统" class="headerlink" title="利用HashMap做一个小型购物车系统"></a>利用HashMap做一个小型购物车系统</h2><h3 id="Product-java"><a href="#Product-java" class="headerlink" title="Product.java"></a>Product.java</h3><pre><code>public class Product {

    private int no;
    private String name;
    private double price;

    public Product() {}

    public Product(int no, String name, double price) {
        this.no = no;
        this.name = name;
        this.price = price;
    }

    public int getNo() {
        return no;
    }

    public void setNo(int no) {
        this.no = no;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public double getPrice() {
        return price;
    }

    public void setPrice(double price) {
        this.price = price;
    }

    public String toString() {
        return &quot; [商品编号]:&quot;+this.no+&quot; [商品名称]:&quot;+this.name+&quot; [商品价格]:&quot;+this.price;
    }

    //如果商品名称和商品编号一样就是同一个商品
    public boolean equals(Object o){
        if(this == o) {
            return true;
        }
        if(o instanceof Product) {
            Product tmp = (Product)o;
            if(tmp.no == this.no &amp;&amp; tmp.name.equals(this.name)) {
                return true;
            }
        }
        return false;
    }

    //货物编号的格式（1000-9999）
    public int hashCode() {
        return this.no/1000;
    }

}</code></pre><h3 id="ShoppingCart-java"><a href="#ShoppingCart-java" class="headerlink" title="ShoppingCart.java"></a>ShoppingCart.java</h3><pre><code>import java.util.*;

public class ShoppingCart {

    double totalPrice;
    Map&lt;Product, Integer&gt; productMaps;

    public ShoppingCart() {
        this.totalPrice = 0.0;
        productMaps = new HashMap&lt;Product, Integer&gt;();
    }

    //增加一个商品进入购物车
    void add(Product p) {
        add(p,1);
    }
    //增加多个商品进入购物车
    void add(Product p, int n) {
        //判断购物车中是否有该类商品
        if(productMaps.containsKey(p)) {
            productMaps.put(p, productMaps.get(p)+n);//自动装箱
        }else {
            productMaps.put(p, n);
        }

        this.totalPrice = this.totalPrice + (n*p.getPrice());
    }

    //删除
    void remove(Product p) {
        remove(p, 1);
    }
    void remove(Product p, int n) {
        //判断这类商品是否存在
        if(productMaps.containsKey(p)) {
            //判断要删除的这个商品是不是只有1个
            if(productMaps.get(p) == 1) {
                productMaps.remove(p);
            }else {
                productMaps.put(p, productMaps.get(p)-n);
            }
        }else {
            System.out.println(&quot;无该类型商品&quot;);
            return ;
        }

        this.totalPrice = this.totalPrice - (n*p.getPrice());
    }

    //清空购物车
    void clear() {
        productMaps.clear();
        this.totalPrice = 0.0;
    }

    //打印账单
    /*
     * 格式：
     *         购物账单：
     *         10         苹果      10元
     *         12         香蕉      20元
     *         ....    
     */
    void print() {
        Set&lt;Product&gt; keys = productMaps.keySet();
        Iterator&lt;Product&gt; it = keys.iterator();
        StringBuffer bf = new StringBuffer();

        bf.append(&quot;购物账单：\n&quot;);
        bf.append(&quot;         货物数量                                            商品信息                                                  应付价格\n&quot;);

        while(it.hasNext()) {
            Product product = it.next();
            Integer number = productMaps.get(product);
            bf.append(&quot;\t&quot;+number.intValue()+&quot;\t&quot;+product+&quot;\t&quot;+(number*product.getPrice())+&quot;\n&quot;);
        }

        bf.append(&quot;\t\t\t\t\t\t\t总价是：&quot;+this.totalPrice+&quot;元&quot;);
        System.out.println(bf);
    }

}</code></pre><h3 id="Test-java"><a href="#Test-java" class="headerlink" title="Test.java"></a>Test.java</h3><pre><code>public class Test {

    public static void main(String[] args) {

        ShoppingCart shop = new ShoppingCart();

        Product p1 = new Product(101, &quot;苹果&quot;, 2.0);
        Product p2 = new Product(102, &quot;香蕉&quot;, 3.0);
        Product p3 = new Product(103, &quot;西瓜&quot;, 4.0);
        Product p4 = new Product(104, &quot;荔枝&quot;, 5.0);
        Product p5 = new Product(105, &quot;芒果&quot;, 6.0);

        shop.add(p1, 2);
        shop.add(p2, 3);
        shop.add(p3, 4);
        shop.add(p4, 5);
        shop.add(p5, 6);

        shop.print();
        System.out.println();

    }

}</code></pre>]]></content>
      <tags>
        <tag>HashMap/HashSet</tag>
      </tags>
  </entry>
  <entry>
    <title>Joint application of Exception, IO and recursion in Java SE</title>
    <url>/blog01.html</url>
    <content><![CDATA[<p>Joint application of Exception, IO and recursion in Java SE</p>
<a id="more"></a>
<h3 id="查找一个目录下所有子路径和子文件："><a href="#查找一个目录下所有子路径和子文件：" class="headerlink" title="查找一个目录下所有子路径和子文件："></a>查找一个目录下所有子路径和子文件：</h3><pre><code>import java.io.*;

public class SeekFiles {

    public static void main(String[] args) {

        File file = new File(&quot;D:\\JAVA Code Base\\Java Exercises\\src&quot;);
        SeekFiles.seekFiles(file);

    }

    public static void seekFiles(File file) {

        if(file.isFile()) {
            return ;
        }

        File[] files = file.listFiles();
        for(File subFile : files) {
            System.out.println(subFile.getAbsolutePath());
            seekFiles(subFile);
        }

    }

}</code></pre><h3 id="批量复制文件："><a href="#批量复制文件：" class="headerlink" title="批量复制文件："></a>批量复制文件：</h3><pre><code>import java.io.*;

public class CopyFiles {

    public static void main(String[] args) {

        File file = new File(&quot;D:\\JAVA Code Base\\Java Exercises\\src&quot;);
        CopyFiles.copyFile(file);

    }

    public static void copyFile(File file) {

        if(file.isFile()) {//判断是否为文件，不是就是路径
            String filePath = file.getAbsolutePath();
            String newFilePath = &quot;C&quot;+filePath.substring(1);
            File parentFile = new File(newFilePath).getParentFile();
            if(!parentFile.exists()) {//判断父路径是否存在
                parentFile.mkdirs();
            }

            FileInputStream fis = null;
            FileOutputStream fos = null;

            try {
                fis = new FileInputStream(filePath);
                fos = new FileOutputStream(newFilePath);

                byte[] bytes = new byte[1024000];//每次拷贝100kb
                int temp = 0;
                while((temp=fis.read(bytes)) != -1){
                    fos.write(bytes, 0, temp);
                }

                fos.flush();
            }catch (Exception e) {
                e.printStackTrace();
            }finally {
                if(fis != null) {
                    try {
                        fis.close();
                    }catch(Exception e) {
                        e.printStackTrace();
                    }
                }
                if(fos != null) {
                    try {
                        fos.close();
                    }catch(Exception e) {
                        e.printStackTrace();
                    }
                }
            }
            return ;
        }

        File[] files = file.listFiles();
        for(File subFile : files) {
            copyFile(subFile);
        }

    }

}</code></pre>]]></content>
      <tags>
        <tag>io/Exception/recursion</tag>
      </tags>
  </entry>
  <entry>
    <title>Joint application of Exception, Multithreading in Java SE</title>
    <url>/blog02.html</url>
    <content><![CDATA[<p>Joint application of Exception, Multithreading in Java SE</p>
<a id="more"></a>
<p>##双线程交替输出1，2，3，4…</p>
<p>###Number.class</p>
<pre><code>public class Number {

    int number;

    public Number(int number) {
        this.number = number;
    }

    public synchronized void printOdd() {
        System.out.println(Thread.currentThread().getName() + &quot;----&gt;&quot; + this.number++);//t1执行
        this.notifyAll();//把t2唤醒，此时t2没有对象锁，处于就绪状态
        try {
            Thread.sleep(1000);
            this.wait();//1s后，将t1睡眠，t1归还对象锁，t2获取对象锁
        }catch(Exception e) {
            e.printStackTrace();
        }
    }

    public synchronized void printEven() {
        System.out.println(Thread.currentThread().getName() + &quot;----&gt;&quot; + this.number++);//t2执行
        this.notifyAll();//把t1唤醒，此时t1没有对象锁，处于就绪状态
        try {
            Thread.sleep(1000);
            this.wait();//1s后，将t2睡眠，t2归还对象锁，t1获取对象锁
        }catch(Exception e) {
            e.printStackTrace();
        }
    }

}</code></pre><p>###PrintOdd.class</p>
<pre><code>public class PrintOdd implements Runnable {

    Number num;

    public PrintOdd(Number num) {
        this.num = num;
    }

    public void run() {
        while(true) {
            this.num.printOdd();
        }
    }

}</code></pre><p>###PrintEven.class</p>
<pre><code>public class PrintEven implements Runnable{

    Number num;

    public PrintEven(Number num) {
        this.num = num;
    }

    public void run() {
        while(true) {
            this.num.printEven();
        }
    }

}</code></pre><p>###Test.class</p>
<pre><code>public class Text {

public static void main(String[] args) throws Exception {

    Number num = new Number(1);

    Thread t1 = new Thread(new PrintOdd(num));//双线程共享同一数据
    t1.setName(&quot;t1&quot;);

    Thread t2 = new Thread(new PrintEven(num));
    t2.setName(&quot;t2&quot;);

    t1.start();//让t1先执行

    Thread.sleep(1000);

    t2.start();

}</code></pre><p>}</p>
]]></content>
      <tags>
        <tag>Exception/Thread</tag>
      </tags>
  </entry>
</search>
