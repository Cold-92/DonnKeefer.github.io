<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>通过注解实现依赖注入</title>
    <url>/blog14.html</url>
    <content><![CDATA[<p>通过注解实现依赖注入</p>
<a id="more"></a>
<h3 id="Person-java"><a href="#Person-java" class="headerlink" title="Person.java"></a>Person.java</h3><pre><code>public class Person {

    private String name;
    private Integer age;
    private String sex;

    @MyAnnotation({&quot;华文暄&quot;, &quot;18&quot;, &quot;男&quot;})
    public Person(){}

    public void setName(String name){
        this.name = name;
    }
    public void setAge(Integer age){
        this.age = age;
    }
    public void setSex(String sex){
        this.sex = sex;
    }

    public String toString(){
        return &quot;{&quot;+this.name+&quot;,&quot;+this.age+&quot;,&quot;+this.sex+&quot;}&quot;;
    }

}</code></pre><h3 id="MySpring-java"><a href="#MySpring-java" class="headerlink" title="MySpring.java"></a>MySpring.java</h3><pre><code>/*
    目的：IOC控制反转思想实现对象托管，利用自定义注解实现依赖注入
    步骤：
        获取类
        获取构造方法
        创建对象
        获取注解对象
        获取注解对象中的信息
        获取该类所有属性
        获取每个属性对应的set方法
        通过注解对象中的信息和set方法实现依赖注入
*/
public class MySpring {

    public Object getBean(String className) throws Exception{
        Object object = null;

        try{
            Class clazz = Class.forName(className);

            Constructor constructor = clazz.getConstructor();

            object = constructor.newInstance();

            Annotation annotation = constructor.getAnnotation(MyAnnotation.class);

            Class aClass = annotation.getClass();
            Method aMethod = aClass.getMethod(&quot;value&quot;);
            String[] values = (String[])aMethod.invoke(annotation);

            Field[] fields = clazz.getDeclaredFields();

            for(int i = 0; i &lt; fields.length; i++){
                String fieldName = fields[i].getName();
                String firstLetter = fieldName.substring(0, 1).toUpperCase();
                String otherLetters = fieldName.substring(1);
                StringBuilder setMethod = new StringBuilder(&quot;set&quot;);
                setMethod.append(firstLetter);
                setMethod.append(otherLetters);

                Class fieldType = fields[i].getType();
                Constructor fieldConstructor = fieldType.getConstructor(String.class);

                Method method = clazz.getMethod(setMethod.toString(), fieldType);
                method.invoke(object, fieldConstructor.newInstance(values[i]));
            }
        }catch(Exception e){
            e.printStackTrace();
        }

        return object;
    }

}</code></pre><h3 id="MyAnnotation"><a href="#MyAnnotation" class="headerlink" title="MyAnnotation"></a>MyAnnotation</h3><pre><code>//静态导入
import static java.lang.annotation.ElementType.*;
import java.lang.annotation.Retention;
import static java.lang.annotation.RetentionPolicy.*;
import java.lang.annotation.Target;

@Target(CONSTRUCTOR)
@Retention(RUNTIME)
public @interface MyAnnotation {

    String[] value();

}</code></pre><h3 id="TestMain-java"><a href="#TestMain-java" class="headerlink" title="TestMain.java"></a>TestMain.java</h3><pre><code>public class TestMain {

    public static void main(String[] args) throws Exception {
        MySpring mySpring = new MySpring();

        Person person = (Person)mySpring.getBean(&quot;javaSE.annotation.Person&quot;);

        System.out.println(person);
    }

}</code></pre>]]></content>
      <tags>
        <tag>IOC/Spring/Reflection/Annotation</tag>
      </tags>
  </entry>
  <entry>
    <title>IOC控制反转和依赖注入</title>
    <url>/blog13.html</url>
    <content><![CDATA[<p>控制反转和依赖注入的混合应用</p>
<a id="more"></a>
<h3 id="Person-java"><a href="#Person-java" class="headerlink" title="Person.java"></a>Person.java</h3><pre><code>public class Person {

    private String name;
    private Integer age;

    public Person(){}
    public Person(String name, Integer age){
        this.name = name;
        this.age = age;
    }

    public void setName(String name){
        this.name = name;
    }
    public void setAge(Integer age){
        this.age = age;
    }

    public String toString(){
        return &quot;{&quot;+this.name+&quot;,&quot;+this.age+&quot;}&quot;;
    }

}</code></pre><h3 id="MySpring-java"><a href="#MySpring-java" class="headerlink" title="MySpring.java"></a>MySpring.java</h3><pre><code>/*
    利用IOC控制反转的思想，把Person类的创建交给MySpring类来创建，并赋值
    思路：
        先获取Person类
        通过Person类创建Person对象
        通过Person类获取所有属性
        通过获取到的每个属性找到Person类中的set方法给每个属性赋值（值采用键盘输入）
        同时考虑输入值的类型不同如何处理
*/

public class MySpring {

    public Object getBean(String className) throws Exception {
        Scanner scanner = new Scanner(System.in);
        //获取类
        Class clazz = Class.forName(className);
        //创建未赋值的对象
        Object object = clazz.newInstance();
        //获取该类中所有属性
        Field[] fields = clazz.getDeclaredFields();
        //通过获取的属性解析属性名，找到对应set方法赋值
        for(Field field : fields){
            //拼添加属性的方法名
            String firstLetter = field.getName().substring(0, 1).toUpperCase();
            String otherLetter = field.getName().substring(1);
            StringBuilder setMethod = new StringBuilder(&quot;set&quot;);
            setMethod.append(firstLetter);
            setMethod.append(otherLetter);
            //手动添加属性值
            System.out.println(&quot;请输入&quot;+field.getName()+&quot;:&quot;);
            String value = scanner.nextLine();
            //获取相对应的set方法,同时注意参数属性的问题
            //因为包装类除了Char其他都有只有String的构造方法，所以可以通过获取到的构造
            //方法把String转换为bean中相应的数据类型再作为参数传递给set方法调用
            Class fieldClass = field.getType();
            Constructor constructor = fieldClass.getConstructor(String.class);//（形参类型）
            Method method = clazz.getMethod(setMethod.toString(), fieldClass);//（方法名，形参类型）
            method.invoke(object, constructor.newInstance(value));//（对象，实参）
        }

        System.out.println(object);

        return object;
    }

}</code></pre><h3 id="TestMain-java"><a href="#TestMain-java" class="headerlink" title="TestMain.java"></a>TestMain.java</h3><pre><code>public class TestMain {

    public static void main(String[] args) throws Exception {
        MySpring mySpring = new MySpring();
        mySpring.getBean(&quot;javaSE.reflection.Person&quot;);
    }

}</code></pre>]]></content>
      <tags>
        <tag>IOC/Spring/Reflection</tag>
      </tags>
  </entry>
  <entry>
    <title>HashMap And HashSet Complete The Login Function</title>
    <url>/blog11.html</url>
    <content><![CDATA[<p>HashMap And HashSet Complete The Login Function</p>
<a id="more"></a>
<h3 id="利用HashMap和HashSet分别完成登录功能"><a href="#利用HashMap和HashSet分别完成登录功能" class="headerlink" title="利用HashMap和HashSet分别完成登录功能"></a>利用HashMap和HashSet分别完成登录功能</h3><pre><code>import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;

public class Login {

    //使用HashSet完成登录功能
    private HashSet&lt;String&gt; userBox1 = new HashSet&lt;&gt;();

    {
        userBox1.add(&quot;张三-123&quot;);
        userBox1.add(&quot;李四-666&quot;);
        userBox1.add(&quot;王五-342&quot;);
    }

    public String login1(String userName, String password){
        //使用增强for循环遍历
//        for(String e : userBox){
//            String[] user = e.split(&quot;-&quot;);
//            if(user[0].equals(userName)){
//                if(user[1].equals(password)){
//                    return &quot;登录成功&quot;;
//                }
//                break;
//            }
//        }
        //使用迭代器遍历
        Iterator&lt;String&gt; iterator = userBox1.iterator();
        while(iterator.hasNext()){
            String[] user = iterator.next().split(&quot;-&quot;);
            if(user[0].equals(userName)){
                if(user[1].equals(password)){
                    return &quot;登录成功&quot;;
                }
                break;
            }
        }
        return &quot;登录失败&quot;;
    }


    //使用HashMap完成登录
    private HashMap&lt;String, String&gt; userBox2 = new HashMap&lt;&gt;();

    {
        userBox2.put(&quot;张三&quot;, &quot;123&quot;);
        userBox2.put(&quot;李四&quot;, &quot;666&quot;);
        userBox2.put(&quot;王五&quot;, &quot;342&quot;);
    }

    //不在需要循环遍历查找，直接定位更快速
    public String login2(String userName, String userPassword){
        String password = userBox2.get(userName);
        if(password.equals(userPassword)){
            return &quot;登录成功&quot;;
        }else{
            return &quot;登录失败&quot;;
        }
    }

    public static void main(String[] args){
        Login login = new Login();
        System.out.println(login.login2(&quot;张三&quot;, &quot;123&quot;));
    }

}</code></pre>]]></content>
      <tags>
        <tag>Collection/Map</tag>
      </tags>
  </entry>
  <entry>
    <title>Simple Examination System</title>
    <url>/blog12.html</url>
    <content><![CDATA[<p>Simple Examination System</p>
<a id="more"></a>
<h3 id="完成一个简易的考试系统"><a href="#完成一个简易的考试系统" class="headerlink" title="完成一个简易的考试系统"></a>完成一个简易的考试系统</h3><h4 id="Student-java"><a href="#Student-java" class="headerlink" title="Student.java"></a>Student.java</h4><pre><code>public class Student {

    private String userName;
    private String password;

    public Student(String userName, String password){
        this.userName = userName;
        this.password = password;
    }

    public String getUserName(){
        return this.userName;
    }

    public String getPassword(){
        return this.password;
    }

}</code></pre><h4 id="Teacher-java"><a href="#Teacher-java" class="headerlink" title="Teacher.java"></a>Teacher.java</h4><pre><code>public class Student {

    private String userName;
    private String password;

    public Student(String userName, String password){
        this.userName = userName;
        this.password = password;
    }

    public String getUserName(){
        return this.userName;
    }

    public String getPassword(){
        return this.password;
    }

}</code></pre><h4 id="ExamMachine-java"><a href="#ExamMachine-java" class="headerlink" title="ExamMachine.java"></a>ExamMachine.java</h4><pre><code>import java.util.ArrayList;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Random;

public class ExamMachine {

    private HashMap&lt;String, String&gt; userBox = new HashMap&lt;String, String&gt;();
    {
        userBox.put(&quot;张三&quot;, &quot;123&quot;);
        userBox.put(&quot;李四&quot;, &quot;222&quot;);
        userBox.put(&quot;王五&quot;, &quot;333&quot;);
    }

    private HashSet&lt;Question&gt; paperBank = new HashSet&lt;Question&gt;();
    {
        paperBank.add(new Question(&quot;第一道题&quot;,&quot;a&quot;));
        paperBank.add(new Question(&quot;第二道题&quot;,&quot;a&quot;));
        paperBank.add(new Question(&quot;第三道题&quot;,&quot;a&quot;));
        paperBank.add(new Question(&quot;第四道题&quot;,&quot;a&quot;));
        paperBank.add(new Question(&quot;第五道题&quot;,&quot;a&quot;));
        paperBank.add(new Question(&quot;第六道题&quot;,&quot;a&quot;));
        paperBank.add(new Question(&quot;第七道题&quot;,&quot;a&quot;));
    }

    //生成试卷
    //数据选择使用ArrayList存储
    public ArrayList&lt;Question&gt; getPaper(int size){
        //防止重复题构建的临时试卷
        HashSet&lt;Question&gt; paper = new HashSet&lt;Question&gt;(size);
        //将题库暂存到可以随机抽题的缓存中
        ArrayList&lt;Question&gt; paperBank = new ArrayList&lt;Question&gt;(this.paperBank);
        while(paper.size() != size){
            //抽题号
            int index = new Random().nextInt(paperBank.size());
            paper.add(paperBank.get(index));
        }
        //将临时试卷转成最终ArrayList形式
        return new ArrayList&lt;Question&gt; (paper);
    }

    public String login(Student student){
        String userName = student.getUserName();
        String password = student.getPassword();
        if(userName != null &amp;&amp; userBox.get(userName).equals(password)){
            return &quot;登录成功&quot;;
        }
        return &quot;用户名或密码错误！&quot;;
    }

    public String[] answerQustion(ArrayList&lt;Question&gt; paper){
        //效果
        System.out.println(&quot;正在加载试题，请稍后！&quot;);
        try{
            Thread.sleep(3000);
        }catch(Exception e){
            e.printStackTrace();
        }

        java.util.Scanner input = new java.util.Scanner(System.in);
        int index = 0;
        String[] answers = new String[paper.size()];
        while(index != paper.size()){
            System.out.println((index+1) + paper.get(index).getTitle());
            System.out.print(&quot;请输入您的答案：&quot;);
            answers[index++] = input.nextLine();
        }
        return answers;
    }

}</code></pre><h4 id="Test-java"><a href="#Test-java" class="headerlink" title="Test.java"></a>Test.java</h4><pre><code>import java.util.ArrayList;

public class Test {

    public static void main(String[] args){
        ExamMachine examMachine = new ExamMachine();

        java.util.Scanner input = new java.util.Scanner(System.in);
        System.out.println(&quot;请输入用户名：&quot;);
        String userName = input.nextLine();
        System.out.println(&quot;请输入密码：&quot;);
        String password = input.nextLine();
        Student student = new Student(userName, password);

        //模拟学生登录
        String result = examMachine.login(student);
        if(result.equals(&quot;登录成功&quot;)){
            //生成试卷
            ArrayList&lt;Question&gt; paper = examMachine.getPaper(5);
            //学生答题
            String[] answers = examMachine.answerQustion(paper);
            //老师阅卷
            Teacher teacher = new Teacher();
            System.out.println(&quot;您本次考试成绩位：&quot; +  teacher.checkPaper(paper, answers));
        }
    }

}</code></pre>]]></content>
      <tags>
        <tag>Collection/Thread</tag>
      </tags>
  </entry>
  <entry>
    <title>String Operation Exercises</title>
    <url>/blog10.html</url>
    <content><![CDATA[<p>字符串操作练习</p>
<a id="more"></a>
<h3 id="一共八道题，八个方法"><a href="#一共八道题，八个方法" class="headerlink" title="一共八道题，八个方法"></a>一共八道题，八个方法</h3><pre><code>public class Test {

    public static void main(String[] args) {
        String str1 = &quot;ok&quot;;
        Test.m1(str1);
        Test.m11(str1);
        Test.m111(str1);

        Test.m2(str1);

        String str2 = &quot;abccba&quot;;
        String str3 = &quot;abcba&quot;;
        Test.m3(str2);
        Test.m3(str3);

        String str4 = &quot;helloworld&quot;;
        Test.m4(str4, 2);

        String str5 = &quot;abc,abcd,ab&quot;;
        Test.m5(str5);

        String str6 = &quot;abcda&quot;;
        Test.m6(str6, &apos;a&apos;);
        Test.m61(str6, &apos;a&apos;);

        String str7 = &quot;this is a bad gay&quot;;
        Test.m7(str7);

        String str8 = &quot;abc11ds32&quot;;
        Test.m8(str8);
    }


    //字符串反转
    //思路：拆成char[]，反向拼接
    public static void m1(String str){
        String resultStr = &quot;&quot;;
        char[] values = str.toCharArray();

        for(int i = values.length-1; i &gt;= 0; i--){
            resultStr = resultStr.concat(values[i] + &quot;&quot;);
        }

        System.out.println(resultStr);
    }
    //第二种方法
    public static void m11(String str){
        char[] values = str.toCharArray();

        for(int i = 0; i &lt; values.length/2; i++){
            char temp = values[i];
            values[i] = values[values.length-1-i];
            values[values.length-1-i] = temp;
        }

        System.out.println(new String(values));
    }
    //第三种方法
    public static void m111(String str){
        System.out.println(new String(new StringBuffer(str).reverse()));
    }


    //字符串正序和反序进行连接
    //思路：将目标字符串拆成char[]，正向拼接一次，反向拼接一次
    public static void m2(String str){
        String resultStr = &quot;&quot;;
        char[] values = str.toCharArray();

        for(int i = 0; i &lt; values.length; i++){
            resultStr = resultStr.concat(values[i]+&quot;&quot;);//char转换成String才能拼接
        }

        for(int i = values.length-1; i &gt;= 0; i--){
            resultStr = resultStr.concat(values[i]+&quot;&quot;);
        }

        System.out.println(resultStr);
    }


    //判断给定字符串是否是回文
    //思路：String拆成char[]，首位各做一个标记，往中遍历
    //注意：char[]有可能是双数，有可能是单数，如果循环条件是 i ！= j，双数的i，j永远不会相等
    //     比如判断abcba，i要走到1，j走到3，最后都遍历到2，循环跳出
    //     如果判断abccba，i要走到2，j要走到3，永不会碰到
    //     所以，把握住i和j是同时移动的，只看一边就行，在abcba中，如果i走到2还没报错，那String就一定是回文
    public static void m3(String str){
        char[] values = str.toCharArray();

        for(int i = 0,j = values.length-1; i &lt;= values.length/2; i++,j--){
            if(values[i] != values[j]){
                System.out.println(&quot;false&quot;);
                return;
            }
        }

        System.out.println(&quot;true&quot;);
        return;
    }


    //将给定字符串右位移x个位置
    //例如，(&quot;helloworld&quot;, 2)----&gt;&quot;ldhellowor&quot;
    //思路：将String按照要移动的位数分成两个子串，再将两个子串反向连接
    //注意：如果要右移的位数超过本身字符串长度要取模处理
    //     在拆分子串的时候注意边界问题
    public static void m4(String str, int x){
        int realMove = x%str.length();

        String subString1 = str.substring(str.length() - realMove);
        String subString2 = str.substring(0, str.length() - realMove);//左闭右开

        subString1 = subString1.concat(subString2);

        System.out.println(subString1);
    }


    //寻找若干字符串中最长的那一个
    //例如，&quot;abc,abcd,ab&quot;---&gt;&quot;abcd&quot;
    //思路：将字符串按照逗号分隔，然后逐个比长度
    public static void m5(String str){
        String[] values = str.split(&quot;,&quot;);

        int maxLengh = 0;
        for(int i = 0; i &lt; values.length; i++){
            if(values[i].length() &gt; values[maxLengh].length()){
                maxLengh = i;
            }
        }

        System.out.println(values[maxLengh]);
    }


    //统计一个字符串中某个字符出现的次数
    public static void m6(String str, char letter){
        int count = 0;

        for(int i = 0; i &lt; str.length(); i++){
            if(str.charAt(i) == letter){
                count++;
            }
        }

        System.out.println(count);
    }
    //第二种方法，用空字符串替换源字符串中的目标字母，然后比较两个字符串的长度
    public static void m61(String str, char letter){
        System.out.println(str.length() - str.replace(String.valueOf(letter), &quot;&quot;).length());
    }


    //将一个字符串中每一个单词首字母大写
    //思路：先按照空格将源字符串分割成一个个部分，把这个部分分成第一个字母和其他字母，将第一个字母大写
    //     拼回去成一个单词，最后再连起来
    //注意：toUpperCase()只能将全部小写变大写
    public static void m7(String str){
        String result = &quot;&quot;;
        String[] values = str.split(&quot; &quot;);

        for(int i = 0; i &lt; values.length; i++){
            String firstLetter = values[i].substring(0, 1).toUpperCase();//左闭右开
            String otherLetters = values[i].substring(1);

            String word = firstLetter.concat(otherLetters);
            result = result.concat(word + &quot; &quot;);
        }

        System.out.println(result.trim());//去掉最后的空格
    }


    //获取字符串中全部数字
    //思路：判断每一个字符是否是数字字符，然后拼接一个新串
    public static void m8(String str){
        String result = &quot;&quot;;

        for(int i = 0; i &lt; str.length(); i++){
            if(str.charAt(i) &gt;= &apos;0&apos; &amp;&amp; str.charAt(i) &lt;= &apos;9&apos;)
                result = result.concat(str.charAt(i)+&quot;&quot;);
        }

        System.out.println(Integer.parseInt(result));//以数字返回
    }

}</code></pre>]]></content>
      <tags>
        <tag>String</tag>
      </tags>
  </entry>
  <entry>
    <title>单例模式</title>
    <url>/blog09.html</url>
    <content><![CDATA[<p>单例模式</p>
<a id="more"></a>
<h3 id="单例模式之懒汉式与饿汉式"><a href="#单例模式之懒汉式与饿汉式" class="headerlink" title="单例模式之懒汉式与饿汉式"></a>单例模式之懒汉式与饿汉式</h3><h4 id="懒汉式"><a href="#懒汉式" class="headerlink" title="懒汉式"></a>懒汉式</h4><pre><code>//懒汉式：用时才创建对象
public class Singleton{

    private Singleton(){}

    private static Singleton singleton;

    public Singleton getSingleton(){
        if(singleton == null){
            singleton = new Singleton();
        }
        return singleton;
    }

}</code></pre><h4 id="饿汉式"><a href="#饿汉式" class="headerlink" title="饿汉式"></a>饿汉式</h4><pre><code>//饿汉式：类一旦加载就产生对象，可能会造成服务器压力问题
public class Singleton {

    //构造方法私有，不让外界获取
    private Singleton(){}

    //只给外界提供一个对象，并保护对象安全
    private static Singleton singleton;

    public Singleton getSingleton(){
        return singleton;
    }

}</code></pre>]]></content>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>Functional Programming And Lambda Expressions in Java SE</title>
    <url>/blog08.html</url>
    <content><![CDATA[<p>Functional Interfaces And Lambda Expressions in Java SE</p>
<a id="more"></a>
<h3 id="函数式接口和Lambda表达式的使用"><a href="#函数式接口和Lambda表达式的使用" class="headerlink" title="函数式接口和Lambda表达式的使用"></a>函数式接口和Lambda表达式的使用</h3><h4 id="函数式接口作参数"><a href="#函数式接口作参数" class="headerlink" title="函数式接口作参数"></a>函数式接口作参数</h4><pre><code>public class demo01 {

    public static void startThread(Runnable runnable){
        Thread thread = new Thread(runnable);
        thread.start();
    }

    public static void main(String[] args) {

        //传统匿名内部类做为参数
        demo01.startThread(new Runnable(){
            @Override
            public void run() {
                System.out.println(Thread.currentThread().getName()+&quot;---&gt;&quot;+&quot;已启动&quot;);
            }
        });

        //lambda表达式做参数
        demo01.startThread(()-&gt;{
            System.out.println(Thread.currentThread().getName()+&quot;---&gt;&quot;+&quot;已启动&quot;);
        });

        //优化过后的lambda表达式做参数
        demo01.startThread(()-&gt; System.out.println(Thread.currentThread().getName()+&quot;---&gt;&quot;+&quot;已启动&quot;));

    }

}</code></pre><h4 id="函数式接口作返回值"><a href="#函数式接口作返回值" class="headerlink" title="函数式接口作返回值"></a>函数式接口作返回值</h4><pre><code>//函数式接口做返回值
public class demo02 {

    //比较器的实现
    public static Comparator&lt;String&gt; getComparator(){

        //匿名内部类实现接口
//        return new Comparator&lt;String&gt;() {
//            @Override
//            public int compare(String o1, String o2) {
//                return o1-o2;
//            }
//        }

        //lambda表达式实现接口
//        return (String o1, String o2)-&gt;{
//            //字符串长度升序排序
//            return o1.length()-o2.length();
//        };

        //优化lambda表达式
        //字符串长度降序排序
        return (o1, o2)-&gt;o2.length()-o1.length();

    }

    public static void main(String[] args) {

        String[] strings = {&quot;aaa&quot;, &quot;bbbb&quot;, &quot;ccccc&quot;};

        //调用Arrays中sort方法对字符串数组进行排序，需要提供比较器
        Arrays.sort(strings, demo02.getComparator());

        //调用Arrays中toString输出字符串数组
        System.out.println(Arrays.toString(strings));

    }

}</code></pre>]]></content>
      <tags>
        <tag>Lambda/Functional Interface/Thread</tag>
      </tags>
  </entry>
  <entry>
    <title>C/S Development Mode in Java SE Network programming</title>
    <url>/blog07.html</url>
    <content><![CDATA[<p>Simulate File Upload System</p>
<a id="more"></a>
<h3 id="利用C-S开发模式和网络编程，制作一个多线程文件上传系统"><a href="#利用C-S开发模式和网络编程，制作一个多线程文件上传系统" class="headerlink" title="利用C/S开发模式和网络编程，制作一个多线程文件上传系统"></a>利用C/S开发模式和网络编程，制作一个多线程文件上传系统</h3><h4 id="TCPClient-java"><a href="#TCPClient-java" class="headerlink" title="TCPClient.java"></a>TCPClient.java</h4><pre><code>import java.net.*;
import java.io.*;

public class TCPClient {

    public static void main(String[] args) throws Exception{

        //将要上传的文件装载到流中
        FileInputStream fis = new FileInputStream(&quot;D:\\local\\1.png&quot;);

        //创建客户端对象，同时获取服务器端口号
        Socket socket = new Socket(&quot;localhost&quot;, 8888);

        //创建网络输出流对象
        OutputStream os = socket.getOutputStream();
        //一边从本地文件中读文件，一边写到网络输出流中
        int len = 0;
        byte[] bytes = new byte[1024];
        while((len = fis.read(bytes)) != -1){
            os.write(bytes, 0, len);
        }

        //解决read()阻塞的问题，如果注释这行代码，客户端和服务器处于僵持状态
        socket.shutdownOutput();

        //读入服务器返回的信息，输出到控制台
        InputStream is = socket.getInputStream();
        while((len = is.read(bytes)) != -1){
            System.out.println(new String(bytes, 0, len));
        }

        try{
            if(fis != null){
                fis.close();
            }
        }catch(Exception e){
            e.printStackTrace();
        }
        try{
            if(fis != null){
                socket.close();
            }
        }catch(Exception e){
            e.printStackTrace();
        }

    }

}</code></pre><h4 id="TCPServer-java"><a href="#TCPServer-java" class="headerlink" title="TCPServer.java"></a>TCPServer.java</h4><pre><code>import java.net.*;
import java.io.*;
import java.util.*;

public class TCPSever {

    public static void main(String[] args) throws Exception{

        //创建服务器对象，获取请求连接的客户端
        ServerSocket serverSocket = new ServerSocket(8888);

        //保证服务器不关，对多个客户端同时操作
        while(true){
            //一个客户端分配一个线程，提高效率
            new Thread(new Runnable(){

                public void run(){

                   Socket socket = null;
                    FileOutputStream fos = null;
                    try{

                        //获取客户端
                        socket = serverSocket.accept();

                        //创建网络输入流，准备接收文件
                        int len = 0;
                        byte[] bytes = new byte[1024];
                        InputStream is = socket.getInputStream();

                        //判断文件是否存在，不存在创建一个
                        File file = new File(&quot;D:\\upload&quot;);
                        if(file.exists()){
                            file.mkdir();
                        }

                        //一边读入客户端传入的信息，一边写出到指定服务器硬盘中
                        //FileOutputStream如果两次写出的文件名相同，会覆盖
                        //自定义文件名：域名+当前毫秒数+0-999998的随机数
                        String fileName = &quot;itcast&quot; + System.currentTimeMillis() + new Random().nextInt(999999) + &quot;.png&quot;;
                        fos = new FileOutputStream(file + &quot;\\&quot; + fileName);
                        while((len = is.read(bytes)) != -1){
                            fos.write(bytes, 0, len);
                        }

                        //反馈信息给客户端
                        OutputStream os = socket.getOutputStream();
                        os.write(&quot;文件上传成功！&quot;.getBytes());

                    }catch(Exception e){

                        e.printStackTrace();

                    }finally{

                        //释放资源
                        try{
                            if(socket != null){
                                socket.close();
                            }
                            if (fos != null) {
                                fos.close();
                            }
                        }catch(Exception e) {
                            e.printStackTrace();
                        }

                    }

                }

            }).start();

        }

    }

}</code></pre>]]></content>
      <tags>
        <tag>TCP/Thread/net</tag>
      </tags>
  </entry>
  <entry>
    <title>MVC Layered Architecture Foundation Project - ATM System</title>
    <url>/blog06.html</url>
    <content><![CDATA[<p>MVC Layered Architecture Foundation Project - ATM System</p>
<a id="more"></a>
<h3 id="利用MVC分层架构的思想，制作一个初级的ATM系统（集中在Model部分）"><a href="#利用MVC分层架构的思想，制作一个初级的ATM系统（集中在Model部分）" class="headerlink" title="利用MVC分层架构的思想，制作一个初级的ATM系统（集中在Model部分）"></a>利用MVC分层架构的思想，制作一个初级的ATM系统（集中在Model部分）</h3><h4 id="User-txt"><a href="#User-txt" class="headerlink" title="User.txt"></a>User.txt</h4><pre><code>张三-666-1000.0
李四-888-888.0
王五-123-1123.0</code></pre><h4 id="User-java"><a href="#User-java" class="headerlink" title="User.java"></a>User.java</h4><pre><code>//JavaBean层
//存储数据，没有逻辑部分
public class User {

    private String name;
    private String password;
    private Float balence;

    public User(){}
    public User(String name, String password, Float balence){
        this.name = name;
        this.password = password;
        this.balence = balence;
    }

    public String getName() {
        return name;
    }
    public void setName(String name) {
        this.name = name;
    }
    public String getPassword() {
        return password;
    }
    public void setPassword(String password) {
        this.password = password;
    }
    public Float getBalence() {
        return balence;
    }
    public void setBalence(Float balence) {
        this.balence = balence;
    }

}</code></pre><h4 id="AtmDao"><a href="#AtmDao" class="headerlink" title="AtmDao"></a>AtmDao</h4><pre><code>import java.util.HashMap;

//Dao层（AtmDao+FileLoaderAndCommit）---持久层
//操作数据
//操作集合
//无业务逻辑
public class AtmDao {

    //封装出去的部分，专门用户加载文件，更新文件数据
    private FileLoaderAndCommit flac = new FileLoaderAndCommit(&quot;src//atmSystem//User.txt&quot;);
    private HashMap&lt;String, User&gt; userBox = flac.fileLoader();

    //业务服务方法：通过名字找到人,以后从数据库中查可能需要多条语句
    //优化
    public User selectOne(String name){
        return userBox.get(name);
    }

    //业务服务方法：将修改过的数据重新添加到集合之中
    //Map是不可重复的，相同健之间直接覆盖
    public void update(User user){
        userBox.put(user.getName(), user);
        //自动提交
        flac.commit(userBox);
    }

}</code></pre><h4 id="FileLoaderAndCommit"><a href="#FileLoaderAndCommit" class="headerlink" title="FileLoaderAndCommit"></a>FileLoaderAndCommit</h4><pre><code>import java.io.*;
import java.util.HashMap;
import java.util.Iterator;
import java.util.Map;

//专门用来操作文件
//从Dao层拆分出来的
public class FileLoaderAndCommit {

    private String fileName = null;
    public FileLoaderAndCommit(String fileName){
        this.fileName = fileName;
    }

    //用一个容器充当缓存，使得读取速率增高
    //还能用来做数据的修改（覆盖源文件）
    //键为人名，值是一个自定义对象，可读性更好
    private HashMap&lt;String, User&gt; userBox = new HashMap&lt;&gt;();

    //将文件中的信息一次性读入缓存
    public HashMap&lt;String, User&gt; fileLoader(){
        FileReader fileReader = null;
        BufferedReader bufferedReader = null;
        try{
            //获取用户文件
            File file = new File(fileName);
            fileReader = new FileReader(file);
            bufferedReader = new BufferedReader(fileReader);
            //获取每一行的用户信息
            String value = bufferedReader.readLine();
            while(value != null){
                String[] userValues = value.split(&quot;-&quot;);
                User user = new User(userValues[0], userValues[1], Float.parseFloat(userValues[2]));
                userBox.put(user.getName(), user);
                value = bufferedReader.readLine();
            }
        }catch(Exception e){
            e.printStackTrace();
        }finally{
            if(fileReader != null){
                try{
                    fileReader.close();
                }catch(Exception e){
                    e.printStackTrace();
                }
            }
        }
        return userBox;
    }

    //业务服务方法，将临时性数据写到文件里
    public void commit(Map&lt;String, User&gt; userBox){
        FileWriter fileWriter = null;
        BufferedWriter bufferedWriter = null;
        try{
            //创建文件写入流
            File file = new File(fileName);
            fileWriter = new FileWriter(file);
            bufferedWriter = new BufferedWriter(fileWriter);
            //开始覆盖
            Iterator&lt;String&gt; iterator = userBox.keySet().iterator();
            while(iterator.hasNext()){
                User user = userBox.get(iterator.next());
                //频繁字符拼接用StringBuilder
                StringBuilder stringBuilder = new StringBuilder(user.getName());
                stringBuilder.append(&quot;-&quot;);
                stringBuilder.append(user.getPassword());
                stringBuilder.append(&quot;-&quot;);
                stringBuilder.append(user.getBalence());
                //整个一行复制掉原文件顺序对应的一行
                bufferedWriter.write(stringBuilder.toString());
                //将当前整个一行压进去
                bufferedWriter.flush();
                //换一行
                bufferedWriter.newLine();
            }
        }catch(Exception e){
            e.printStackTrace();
            //将缓存中更改后的数据覆盖掉原文件
        }finally{
            try{
                if(fileWriter != null)
                    fileWriter.close();
            }catch(Exception e){
                e.printStackTrace();
            }
        }
    }

}</code></pre><h4 id="AtmService"><a href="#AtmService" class="headerlink" title="AtmService"></a>AtmService</h4><pre><code>//数据处理层，只有业务逻辑
//判断，比较，计算
public class AtmService {
    //需要Dao层支持
    AtmDao dao = new AtmDao();

    //业务方法：登录
    public String login(String name, String password){
        User user = dao.selectOne(name);
        if(user.getPassword() == null &amp;&amp; user.getPassword().equals(password)){
            return &quot;登录成功&quot;;
        }
        return &quot;登录失败&quot;;
    }

    //业务方法：查询余额
    public Float qureyBalence(String name){
        User user = dao.selectOne(name);
        return user.getBalence();
    }

    //业务方法：存款
    public void deposit(String name, Float depositMoney){
        //修改缓存中数据
        User user = dao.selectOne(name);
        user.setBalence(user.getBalence() + depositMoney);
        dao.update(user);
        System.out.println(&quot;存款成功！&quot;);
    }

    //业务方法：取款
    public void withdraw(String name, Float withdrawMoney){
        User user = dao.selectOne(name);
        if(user.getBalence() &gt; withdrawMoney){
            user.setBalence(user.getBalence() - withdrawMoney);
            dao.update(user);
            System.out.println(&quot;取款成功！&quot;);
        }else{
             System.out.println(&quot;对不起&quot; + name + &quot;您的余额不足&quot;);
        }
    }

    //业务方法：转账
    //aName转给bName
    public void transfer(String aName, String bName, Float transferMoney){
        User user1 = dao.selectOne(aName);
        User user2 = dao.selectOne(bName);
        if(user1.getBalence() &lt; transferMoney || user1 == null || user2 == null){
            System.out.println(&quot;对不起&quot; + aName + &quot;您的转账操作失败&quot;);
        }else{
            user1.setBalence(user1.getBalence() - transferMoney);
            user2.setBalence(user2.getBalence() + transferMoney);
            //先更新转帐的人的的钱，再更新被转账的人的钱
            //如果先更新被转账的人的钱，如果再根性转账的人的钱发生异常，银行就会赔钱
            dao.update(user1);
            dao.update(user2);
            System.out.println(&quot;转账成功！&quot;);
        }
    }

}</code></pre><h4 id="AtmTest"><a href="#AtmTest" class="headerlink" title="AtmTest"></a>AtmTest</h4><pre><code>import java.util.*;

public class AtmTest {

    public static void main(String[] args){
        Scanner sc = new Scanner(System.in);

        AtmService atmService = new AtmService();

        System.out.println(&quot;欢迎来到太平洋标准银行&quot;);
        System.out.print(&quot;请输入账号：&quot;);
        String name = sc.nextLine();
        System.out.print(&quot;请输入密码：&quot;);
        String password = sc.nextLine();
        atmService.login(name, password);

        System.out.println(&quot;存款请按1\n取款请按2\n转账请按3\n查询余额请按4&quot;);
        System.out.print(&quot;请输入您的选择：&quot;);
        int input = sc.nextInt();
        sc.nextLine();
        switch(input){
            case 1:
                System.out.print(&quot;请输入要存款的钱数：&quot;);
                Float depositMoney = sc.nextFloat();
                atmService.deposit(name, depositMoney);
                break;
            case 2:
                System.out.print(&quot;请输入要取款的钱数：&quot;);
                Float withdrawMoney = sc.nextFloat();
                atmService.withdraw(name, withdrawMoney);
                break;
            case 3:
                System.out.print(&quot;请输入要转账人的姓名：&quot;);
                String bname = sc.nextLine();
                System.out.print(&quot;请输入要转账的钱数：&quot;);
                Float transferMoney = sc.nextFloat();
                atmService.transfer(name, bname, transferMoney);
            case 4:
                System.out.println(atmService.qureyBalence(name));
        }
    }

}</code></pre>]]></content>
      <tags>
        <tag>HashMap/HashSet/io/MVC</tag>
      </tags>
  </entry>
  <entry>
    <title>Application of HashMap，HashSet in Java SE</title>
    <url>/blob03.html</url>
    <content><![CDATA[<p>Application of HashMap，HashSet in Java SE</p>
<a id="more"></a>
<h3 id="利用HashMap做一个小型购物车系统"><a href="#利用HashMap做一个小型购物车系统" class="headerlink" title="利用HashMap做一个小型购物车系统"></a>利用HashMap做一个小型购物车系统</h3><h4 id="Product-java"><a href="#Product-java" class="headerlink" title="Product.java"></a>Product.java</h4><pre><code>public class Product {

    private int no;
    private String name;
    private double price;

    public Product() {}

    public Product(int no, String name, double price) {
        this.no = no;
        this.name = name;
        this.price = price;
    }

    public int getNo() {
        return no;
    }

    public void setNo(int no) {
        this.no = no;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public double getPrice() {
        return price;
    }

    public void setPrice(double price) {
        this.price = price;
    }

    public String toString() {
        return &quot; [商品编号]:&quot;+this.no+&quot; [商品名称]:&quot;+this.name+&quot; [商品价格]:&quot;+this.price;
    }

    //如果商品名称和商品编号一样就是同一个商品
    public boolean equals(Object o){
        if(this == o) {
            return true;
        }
        if(o instanceof Product) {
            Product tmp = (Product)o;
            if(tmp.no == this.no &amp;&amp; tmp.name.equals(this.name)) {
                return true;
            }
        }
        return false;
    }

    //货物编号的格式（1000-9999）
    public int hashCode() {
        return this.no/1000;
    }

}</code></pre><h4 id="ShoppingCart-java"><a href="#ShoppingCart-java" class="headerlink" title="ShoppingCart.java"></a>ShoppingCart.java</h4><pre><code>import java.util.*;

public class ShoppingCart {

    double totalPrice;
    Map&lt;Product, Integer&gt; productMaps;

    public ShoppingCart() {
        this.totalPrice = 0.0;
        productMaps = new HashMap&lt;Product, Integer&gt;();
    }

    //增加一个商品进入购物车
    void add(Product p) {
        add(p,1);
    }
    //增加多个商品进入购物车
    void add(Product p, int n) {
        //判断购物车中是否有该类商品
        if(productMaps.containsKey(p)) {
            productMaps.put(p, productMaps.get(p)+n);//自动装箱
        }else {
            productMaps.put(p, n);
        }

        this.totalPrice = this.totalPrice + (n*p.getPrice());
    }

    //删除
    void remove(Product p) {
        remove(p, 1);
    }
    void remove(Product p, int n) {
        //判断这类商品是否存在
        if(productMaps.containsKey(p)) {
            //判断要删除的这个商品是不是只有1个
            if(productMaps.get(p) == 1) {
                productMaps.remove(p);
            }else {
                productMaps.put(p, productMaps.get(p)-n);
            }
        }else {
            System.out.println(&quot;无该类型商品&quot;);
            return ;
        }

        this.totalPrice = this.totalPrice - (n*p.getPrice());
    }

    //清空购物车
    void clear() {
        productMaps.clear();
        this.totalPrice = 0.0;
    }

    //打印账单
    /*
     * 格式：
     *         购物账单：
     *         10         苹果      10元
     *         12         香蕉      20元
     *         ....    
     */
    void print() {
        Set&lt;Product&gt; keys = productMaps.keySet();
        Iterator&lt;Product&gt; it = keys.iterator();
        StringBuffer bf = new StringBuffer();

        bf.append(&quot;购物账单：\n&quot;);
        bf.append(&quot;         货物数量                                            商品信息                                                  应付价格\n&quot;);

        while(it.hasNext()) {
            Product product = it.next();
            Integer number = productMaps.get(product);
            bf.append(&quot;\t&quot;+number.intValue()+&quot;\t&quot;+product+&quot;\t&quot;+(number*product.getPrice())+&quot;\n&quot;);
        }

        bf.append(&quot;\t\t\t\t\t\t\t总价是：&quot;+this.totalPrice+&quot;元&quot;);
        System.out.println(bf);
    }

}</code></pre><h4 id="Test-java"><a href="#Test-java" class="headerlink" title="Test.java"></a>Test.java</h4><pre><code>public class Test {

    public static void main(String[] args) {

        ShoppingCart shop = new ShoppingCart();

        Product p1 = new Product(101, &quot;苹果&quot;, 2.0);
        Product p2 = new Product(102, &quot;香蕉&quot;, 3.0);
        Product p3 = new Product(103, &quot;西瓜&quot;, 4.0);
        Product p4 = new Product(104, &quot;荔枝&quot;, 5.0);
        Product p5 = new Product(105, &quot;芒果&quot;, 6.0);

        shop.add(p1, 2);
        shop.add(p2, 3);
        shop.add(p3, 4);
        shop.add(p4, 5);
        shop.add(p5, 6);

        shop.print();
        System.out.println();

    }

}</code></pre>]]></content>
      <tags>
        <tag>HashMap/HashSet</tag>
      </tags>
  </entry>
  <entry>
    <title>Application of Exception, IO and recursion in Java SE</title>
    <url>/blog01.html</url>
    <content><![CDATA[<p>Application of Exception, IO and recursion in Java SE</p>
<a id="more"></a>
<h3 id="查找一个目录下所有子路径和子文件："><a href="#查找一个目录下所有子路径和子文件：" class="headerlink" title="查找一个目录下所有子路径和子文件："></a>查找一个目录下所有子路径和子文件：</h3><pre><code>import java.io.*;

public class SeekFiles {

    public static void main(String[] args) {

        File file = new File(&quot;D:\\JAVA Code Base\\Java Exercises\\src&quot;);
        SeekFiles.seekFiles(file);

    }

    public static void seekFiles(File file) {

        if(file.isFile()) {
            return ;
        }

        File[] files = file.listFiles();
        for(File subFile : files) {
            System.out.println(subFile.getAbsolutePath());
            seekFiles(subFile);
        }

    }

}</code></pre><h3 id="批量复制文件："><a href="#批量复制文件：" class="headerlink" title="批量复制文件："></a>批量复制文件：</h3><pre><code>import java.io.*;

public class CopyFiles {

    public static void main(String[] args) {

        File file = new File(&quot;D:\\JAVA Code Base\\Java Exercises\\src&quot;);
        CopyFiles.copyFile(file);

    }

    public static void copyFile(File file) {

        if(file.isFile()) {//判断是否为文件，不是就是路径
            String filePath = file.getAbsolutePath();
            String newFilePath = &quot;C&quot;+filePath.substring(1);
            File parentFile = new File(newFilePath).getParentFile();
            if(!parentFile.exists()) {//判断父路径是否存在
                parentFile.mkdirs();
            }

            FileInputStream fis = null;
            FileOutputStream fos = null;

            try {
                fis = new FileInputStream(filePath);
                fos = new FileOutputStream(newFilePath);

                byte[] bytes = new byte[1024000];//每次拷贝100kb
                int temp = 0;
                while((temp=fis.read(bytes)) != -1){
                    fos.write(bytes, 0, temp);
                }

                fos.flush();
            }catch (Exception e) {
                e.printStackTrace();
            }finally {
                if(fis != null) {
                    try {
                        fis.close();
                    }catch(Exception e) {
                        e.printStackTrace();
                    }
                }
                if(fos != null) {
                    try {
                        fos.close();
                    }catch(Exception e) {
                        e.printStackTrace();
                    }
                }
            }
            return ;
        }

        File[] files = file.listFiles();
        for(File subFile : files) {
            copyFile(subFile);
        }

    }

}</code></pre>]]></content>
      <tags>
        <tag>IO/Exception/recursion</tag>
      </tags>
  </entry>
  <entry>
    <title>JDBC process structure in Java SE</title>
    <url>/blog04.html</url>
    <content><![CDATA[<p>JDBC process structure in Java SE</p>
<a id="more"></a>

<h3 id="JDBC基本流程六步骤（静态注册）"><a href="#JDBC基本流程六步骤（静态注册）" class="headerlink" title="JDBC基本流程六步骤（静态注册）"></a>JDBC基本流程六步骤（静态注册）</h3><pre><code>import java.sql.*;
import com.mysql.jdbc.Driver;

public class JDBCTest01 {

    public static void main(String[] args) {

        Connection conn = null;
        Statement stmt = null;

        try {

            //①获取和注册驱动
            Driver driver = new com.mysql.jdbc.Driver();
            DriverManager.registerDriver(driver);
            //利用反射机制类加载Driver运行静态代码块注册驱动
            //使用反射机制还需要多处理一个ClassNotFoundException
//            Class.forName(&quot;com.mysql.jdbc.Driver&quot;);
//            DriverManager.registerDriver(new com.mysql.jdbc.Driver());

            //②建立连接
            String url = &quot;jdbc:mysql://127.0.0.1:3306/bjpowernode&quot;;
            String user = &quot;root&quot;;
            String password = &quot;13013005866&quot;;
            conn = DriverManager.getConnection(url, user, password);
//            conn = DriverManager.getConnection(&quot;&quot;, &quot;&quot;, &quot;&quot;);

            //③建立sql操作对象
            stmt = conn.createStatement();

            //④执行sql语句
            //不写分号
            String sql = &quot;insert into dept (deptno, dname, loc) values (50, &apos;人事部&apos;, &apos;北京&apos;)&quot;;
            int count = stmt.executeUpdate(sql);
            System.out.println(count == 1 ? &quot;插入数据成功&quot; : &quot;插入数据失败&quot;);

            //⑤不是select语句，不能经行数据处理，后也如此

        }catch(SQLException e) {

            e.printStackTrace();

        }finally {

            //⑥从小到大释放资源
            try {
                if(stmt != null) {
                    stmt.close();
                }
            }catch(Exception e) {
                e.printStackTrace();
            }

            try {
                if(conn != null) {
                    conn.close();
                }
            }catch(Exception e) {
                e.printStackTrace();
            }

        }

    }

}</code></pre><h3 id="动态注册（IO-Properties）"><a href="#动态注册（IO-Properties）" class="headerlink" title="动态注册（IO+Properties）"></a>动态注册（IO+Properties）</h3><pre><code>import java.sql.*;
import java.io.*;
import java.util.*;

public class JDBCTest02 {

    public static void main(String[] args) throws Exception{//涉及到IO上抛一个异常

        Connection conn = null;
        Statement stmt = null;

        //IO+Properties
        Properties p = new Properties();
        FileInputStream fis = new FileInputStream(&quot;D:\\JAVA Code Base\\Java Exercises\\src\\jdbc\\jdbc.properties&quot;);
        p.load(fis);

        //配置文件获取
        String driver = p.getProperty(&quot;driver&quot;);
        String url = p.getProperty(&quot;url&quot;);
        String user = p.getProperty(&quot;user&quot;);
        String password = p.getProperty(&quot;password&quot;);

        try {

            Class.forName(driver);

            conn = DriverManager.getConnection(url, user, password);

            stmt = conn.createStatement();

            String sql = &quot;update dept set dname = &apos;销售部&apos;, loc = &apos;天津&apos; where  deptno = 20&quot;;
            int count = stmt.executeUpdate(sql);
            System.out.println(count == 1 ? &quot;数据修改成功&quot; : &quot;数据修改失败&quot;);

        }catch (Exception e) {

            e.printStackTrace();

        }finally {

            try {
                if(stmt != null) {
                    stmt.close();
                }
            } catch(Exception e) {
                e.printStackTrace();
            }

            try {
                if(conn != null) {
                    conn.close();
                }
            } catch(Exception e) {
                e.printStackTrace();
            }

        }

    }

}</code></pre><h3 id="动态注册（ResourceBundle）"><a href="#动态注册（ResourceBundle）" class="headerlink" title="动态注册（ResourceBundle）"></a>动态注册（ResourceBundle）</h3><pre><code>import java.sql.*;
import java.util.*;

public class JDBCTest03 {

    public static void main(String[] args) {

        Connection conn = null;
        Statement stmt = null;

        //ResourceBundle
        ResourceBundle bundle = ResourceBundle.getBundle(&quot;D:\\JAVA Code Base\\Java Exercises\\src\\jdbc\\jdbc.properties&quot;);

        配置文件获取
        String driver = bundle.getString(&quot;driver&quot;);
        String url = bundle.getString(&quot;url&quot;);
        String user = bundle.getString(&quot;user&quot;);
        String password = bundle.getString(&quot;password&quot;);

        try {

            Class.forName(driver);

            conn = DriverManager.getConnection(url, user, password);

            stmt = conn.createStatement();

            String sql = &quot;update dept set dname = &apos;销售部&apos;, loc = &apos;天津&apos; where  deptno = 20&quot;;
            int count = stmt.executeUpdate(sql);
            System.out.println(count == 1 ? &quot;数据修改成功&quot; : &quot;数据修改失败&quot;);

        }catch(Exception e) {

            e.printStackTrace();

        }finally {

            try {
                if(stmt != null) {
                    stmt.close();
                }
            } catch(Exception e) {
                e.printStackTrace();
            }

            try {
                if(conn != null) {
                    conn.close();
                }
            } catch(Exception e) {
                e.printStackTrace();
            }

        }

    }

}</code></pre><h3 id="处理查询结果集（IO-Properties）"><a href="#处理查询结果集（IO-Properties）" class="headerlink" title="处理查询结果集（IO+Properties）"></a>处理查询结果集（IO+Properties）</h3><pre><code>import java.sql.*;
import java.util.*;
import java.io.*;

public class JDBCTest04 {

    public static void main(String[] args) throws Exception{

        Connection conn = null;
        Statement stmt = null;
        ResultSet rs = null;

        Properties p = new Properties();
        FileInputStream fis = new FileInputStream(&quot;D:\\JAVA Code Base\\Java Exercises\\src\\jdbc\\jdbc.properties&quot;);
        p.load(fis);

        String driver = p.getProperty(&quot;driver&quot;);
        String url = p.getProperty(&quot;url&quot;);
        String user = p.getProperty(&quot;user&quot;);
        String password = p.getProperty(&quot;password&quot;);

//        ResourceBundle bundle = ResourceBundle.getBundle(&quot;D:\\JAVA Code Base\\Java Exercises\\src\\jdbc\\jdbc.properties&quot;);    
//        String driver = bundle.getString(&quot;driver&quot;);
//        String url = bundle.getString(&quot;url&quot;);
//        String user = bundle.getString(&quot;user&quot;);
//        String password = bundle.getString(&quot;password&quot;);

        try {

            Class.forName(driver);

            conn = DriverManager.getConnection(url, user, password);

            stmt = conn.createStatement();

            String sql = &quot;select ename, sal from emp&quot;;
            rs = stmt.executeQuery(sql);

            //创建查询结果集对象，对查询结果进行操作
            while(rs.next()) {
                String ename = rs.getString(&quot;ename&quot;);
                String sal = rs.getString(&quot;sal&quot;);
                System.out.println(&quot;ename:&quot; + ename + &quot;,&quot; + &quot;sal:&quot; + sal);
            }

        }catch (Exception e) {

            e.printStackTrace();

        }finally {

            if(rs != null) {
                try {
                    rs.close();
                }catch(Exception e) {
                    e.printStackTrace();
                }
            }

            if(stmt != null) {
                try {
                    stmt.close();
                }catch(Exception e) {
                    e.printStackTrace();
                }
            }

            if(conn != null) {
                try {
                    conn.close();
                }catch(Exception e) {
                    e.printStackTrace();
                }
            }

        }

    }

}</code></pre><h3 id="jdbc-properties"><a href="#jdbc-properties" class="headerlink" title="jdbc.properties"></a>jdbc.properties</h3><pre><code>driver=com.mysql.jdbc.Driver
url=jdbc:mysql://localhost:3306/bjpowernode
user=root
password=13013005866</code></pre>]]></content>
      <tags>
        <tag>Reflaction/JDBC</tag>
      </tags>
  </entry>
  <entry>
    <title>Application of Exception, Multithreading in Java SE</title>
    <url>/blog02.html</url>
    <content><![CDATA[<p>Application of Exception, Multithreading in Java SE</p>
<a id="more"></a>
<h3 id="双线程交替输出1，2，3，4…"><a href="#双线程交替输出1，2，3，4…" class="headerlink" title="双线程交替输出1，2，3，4…"></a>双线程交替输出1，2，3，4…</h3><h4 id="Number-java"><a href="#Number-java" class="headerlink" title="Number.java"></a>Number.java</h4><pre><code>public class Number {

    int number;

    public Number(int number) {
        this.number = number;
    }

    public synchronized void printOdd() {
        System.out.println(Thread.currentThread().getName() + &quot;----&gt;&quot; + this.number++);//t1执行
        this.notifyAll();//把t2唤醒，此时t2没有对象锁，处于就绪状态
        try {
            Thread.sleep(1000);
            this.wait();//1s后，将t1睡眠，t1归还对象锁，t2获取对象锁
        }catch(Exception e) {
            e.printStackTrace();
        }
    }

    public synchronized void printEven() {
        System.out.println(Thread.currentThread().getName() + &quot;----&gt;&quot; + this.number++);//t2执行
        this.notifyAll();//把t1唤醒，此时t1没有对象锁，处于就绪状态
        try {
            Thread.sleep(1000);
            this.wait();//1s后，将t2睡眠，t2归还对象锁，t1获取对象锁
        }catch(Exception e) {
            e.printStackTrace();
        }
    }

}</code></pre><h4 id="PrintOdd-java"><a href="#PrintOdd-java" class="headerlink" title="PrintOdd.java"></a>PrintOdd.java</h4><pre><code>public class PrintOdd implements Runnable {

    Number num;

    public PrintOdd(Number num) {
        this.num = num;
    }

    public void run() {
        while(true) {
            this.num.printOdd();
        }
    }

}</code></pre><h4 id="PrintEven-java"><a href="#PrintEven-java" class="headerlink" title="PrintEven.java"></a>PrintEven.java</h4><pre><code>public class PrintEven implements Runnable{

    Number num;

    public PrintEven(Number num) {
        this.num = num;
    }

    public void run() {
        while(true) {
            this.num.printEven();
        }
    }

}</code></pre><h4 id="Test-java"><a href="#Test-java" class="headerlink" title="Test.java"></a>Test.java</h4><pre><code>public class Text {

    public static void main(String[] args) throws Exception {

        Number num = new Number(1);

        Thread t1 = new Thread(new PrintOdd(num));//双线程共享同一数据
        t1.setName(&quot;t1&quot;);

        Thread t2 = new Thread(new PrintEven(num));
        t2.setName(&quot;t2&quot;);

        t1.start();//让t1先执行

        Thread.sleep(1000);

        t2.start();

    }

}</code></pre>]]></content>
      <tags>
        <tag>Exception/Thread</tag>
      </tags>
  </entry>
</search>
